# 三大问题
## 缓存穿透
大量请求 key 是无效的，既不在缓存中，也不在数据库中，导致请求直接穿透到数据库，对数据库造成压力。
### 解决方案
* 缓存无效 Key，设置较短过期时间（治标不治本）。
* 布隆过滤器，将所有可能存在的 key 存入布隆过滤器，不存在的 key 直接拦截（布隆过滤器说不存在就一定不存在）。
* 接口限流，根据 IP 或 ID 进行限流，或将异常频繁的访问行为拉黑。
## 缓存击穿
大量的请求同时访问一个 key，当这个 key 过期时，所有请求都会穿透到数据库，对数据库造成压力。

缓存击穿可以看做是缓存雪崩的子集。
### 解决方案
* 设置热点数据永不过期（不推荐）。
* 缓存预热，提前加载热点数据到缓存中。
* 互斥锁，只允许一个请求访问数据库，其他请求等待。
## 缓存雪崩
大量的 key 无法通过缓存访问，导致请求直接落到数据库，对数据库造成压力。
### 解决方案
* 对于 Redis 服务不可用（宕机）的情况
  * 采用集群部署，保证高可用。
  * 多级缓存，当 Redis 服务不可用时，访问其他缓存。
  * 限流，当 Redis 服务不可用时，只允许少量请求访问数据库。
* 对于大量 key 同时过期的情况
  * 设置不同的过期时间，避免同一时间大量 key 过期。
  * 提前预热。
  * 设置不过期。
## 缓存预热方案
* 定时任务预热，定时将热点数据从数据库查询出来放入缓存。
* 消息队列预热，将热点数据的ID或主键放入消息队列，消费者将数据加载到缓存中。


