## 缓存淘汰算法
### LRU
采用链表实现，每次访问一个元素，将其移动到链表头部，当链表满时，将链表尾部元素删除。传统 LRU 无法避免两个问题：
* 缓存预读失效造成的命中率下降。
* 缓存污染，即缓存中的数据长时间不被访问，但是由于其在缓存中，导致其一直存在。
Linux 和 MySQL 中的 LRU 为了避免这种情况，采用了**冷热数据分离**和**提高热数据门槛**的思想。
### Linux 内核中的 LRU
* 实现了两个 LRU 队列，一个是 Active 队列，一个是 Inactive 队列。
* 预读的数据先进入 Inactive 队列头部
* 当 Inactive 队列中的数据被访问**第 2 次**时（防止缓存污染），将其移动到 Active 队列头部。
* 当 Active 队列满时，将 Active 队列尾部的数据移动到 Inactive 队列头部。

### MySQL 中的 LRU
* 将一个 LRU 队列分为两个部分，一个是 old 区域，一个是 young 区域。
* 预读的数据先进入 young 区域。
* 一个 young 区域的数据被访问**第 2 次**且停留时间超过 1 秒时，将其移动到 old 区域。
* 其他和 Linux 类似。

## 陌生名词
### CPU 亲和性
缓存命中率高对于 CPU 就更加亲和。

### 伪共享
伪共享是指多个线程同时访问不同的变量，但这些变量被缓存在**同一个缓存行**中，这样就会导致多个线程在不同的 CPU 上同时访问同一个缓存行，这样就会导致缓存行的数据被频繁的在多个 CPU 之间传递，从而导致性能下降。

## 参考链接
* [伪共享](https://www.cnblogs.com/jimoer/p/13625368.html)