# 虚拟内存
## 为什么要虚拟内存
* 程序员直接对物理内存进行操作，会导致程序之间相互影响，不利于程序的隔离。
* 引入虚拟内存后，根据程序局部性原理，只有少部分代码必须放在物理内存中，其他代码可以在需要的时候加载，这样可以提高内存的利用率。
* 页表项中除了物理地址还可以保存一些访问控制和标记位，提高安全性。

## Linux 虚拟内存

<img src="/knowledge/assets/os/linux-task-struct.png" width="900">

### 一个进程有哪些虚拟内存区域？
* 代码段：存放程序的代码。
* 数据段：存放程序的全局变量和静态变量。
* BSS 段：存放**未初始化**的全局变量和静态变量。
* 堆：存放动态分配的内存（通过 `brk` 系统调用可以分配内存）
* 文件映射区：存放动态链接库，文件映射区域（通过 `mmap` 系统调用可以将文件映射到内存中）。
* 栈：存放函数的局部变量和函数调用信息。

### 不太理解为什么需要红黑树来维护虚拟内存区域？
难道是虚拟内存区域可能会灵活变化，会有多个？

# 内存管理
## 内存分段
### 分段具体过程
* 程序分为多个段，包括代码段、数据段、堆、栈等。
* 段表中存放了每个段的基址和长度。
* 每个段会有自己的段号，根据它可以在段表中查到具体的内存地址。
### 分段的缺点
* 有外部碎片。
  * 通过把段交换到外存，再把段换入内存，可以解决外部碎片问题（内存交换）。
* 内存交换效率低，因为段一般比较大。

## 内存分页
### 分页具体过程
* 将虚拟内存和物理内存划分为大小相等的页（4KB）。
* 页表中存放了每个页的虚拟页号和物理页号的映射关系。
* 进程访问的虚拟地址在页表中查不到时会触发**缺页中断**，操作系统会将对应的物理页加载到内存中，然后更新页表。

### 分页的优优点
* 消除了外部碎片（但是有少量内部碎片）。
* 交换效率高。
* 页表相比段表会占用更多内存，每个进程都有自己的页表会有比较大开销。

### TLB
* TLB 是一个高速缓存，存放了页表中的部分内容。
* 当 CPU 访问内存时，会先在 TLB 中查找，如果没有则会访问内存。

## 多级页表
根据程序局部性原理，大部分页表项是访问不到的，所以可以引入多级页表来减少页表的开销。

<img src="/knowledge/assets/os/multilevel-page-table.png" width="900">


## 段页式内存管理
段页式可以更好地进行相同逻辑意义的页（在同一个段）的管理。
### 段页式内存查询具体过程
* 根据段号在段表中查找到页表的基址。
* 根据页号在页表中查找到物理页号。
* 根据物理页号和页内偏移量计算出物理地址。

## Linux 内存管理
* Linux 主要采用的时分页机制，但不可避免地会用到段式内存管理（因为底层 CPU 的机制）。
* 但是 Linux 中所有段的初始地址都是一样的，屏蔽了段式内存管理的复杂性。
### Intel x86-64 的内存管理
* 最开始只支持内存分段，后来引入了分页机制，但是分页机制是基于分段机制的。
* 逻辑地址是段式内存管理映射前的地址，线性地址是分页机制映射前的地址（也叫虚拟地址），物理地址是实际的物理地址。


# 参考链接
* [虚拟内存](https://xiaolincoding.com/os/3_memory/vmem.html)
* [深入理解Linux虚拟内存](https://xiaolincoding.com/os/3_memory/linux_mem.html)