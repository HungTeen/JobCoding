## 事务分类
* 刚性事务：要求分布式事务和本地事务一样，支持 CP，适合短事务。
  * 包括 XA 协议（2PC、JTA。JTS）、3PC 等。
* 柔性事务：不要求强一致性，而是最终一致性，实现补偿接口和资源锁定接口，适合高并发。
  * 分为补偿型、异步确保型、最大努力通知型等。
  * 包括 TCC、Saga（状态机模式、Aop 模式）、本地事务消息、消息事务（半消息）。

<img src="/knowledge/assets/seata/transaction.png" width="900">

## XA
### 2PC
2 Phase Commit，两阶段提交，标准的 XA 模式。
#### 阶段一（Prepare/Voting）
* 事务询问。
* 事务执行，并记录回滚。
* 询问参与者的执行结果。
#### 阶段二（Commit）
如果阶段一收到的都是成功，则执行提交（commit），否则执行回滚（rollback）。
* 发送提交请求：协调者向所有参与者发送 commit/rollback 消息。
* 事务提交：参与者收到 commit 消息后，执行事务提交。
* 事务回滚：参与者收到 rollback 消息后，根据回滚日志，执行事务回滚。
* 反馈结果：执行成功后返回 ACK 消息。
* 事务结束：协调者收到所有 ACK 消息后，完成事务。

<img src="/knowledge/assets/seata/2pc.png" width="900">

#### 2PC 优缺点
* 实现原理简单。
* 协调者是个单点，容易造成单点故障。
* 性能问题：执行完之前都需要阻塞等待。
* 数据不一致：如果 commit 时参与者没收到消息，可能导致数据不一致。
* 保守：异常方案严重依赖于超时机制，可能导致长时间阻塞。

### 3PC
3 Phase Commit，三阶段提交。
#### 阶段一（CanCommit）
* 协调者向所有参与者询问是否能够执行事务。
* 参与者根据自身情况回复一个预估值。
#### 阶段二（PreCommit）
* 如果所有参与者都回复 YES，则开始执行事务（类似于把 2PC 的第一步拆成了两步）。
* 否则，协调者发送 abort，中止事务。
#### 阶段三（DoCommit）

<img src="/knowledge/assets/seata/3pc.png" width="900">

#### 3PC 的优化
* 协调者和参与者都设置了超时时间，避免参与者无法与协调者通信导致的阻塞（自动 commit）。
* 但还是存在数据不一致的问题。

## 异步确保型
适用于内部系统的最终一致性保障。
### MQ 事务消息
事务消息是一种半消息，提交前会将消息放入一个特殊的事务队列（消费者不可见），等到事务提交后再将消息发送到正常的队列进行消费。

<img src="/knowledge/assets/seata/transaction-message.png" width="750">

### 本地消息表
* 需要一个消息表来保存事务消息。
* 业务数据和消息表都在本地数据库，确保本地事务。
* 使用专门的工作线程读取消息表，发送消息。

#### 本地消息表的优缺点
* 成本低，实现最终一致性。
* 无需回查，减少侵入性。
* 表的字段不好扩展，不灵活。
* 依赖于数据库，数据库性能可能会成为瓶颈。

#### MQ 事务消息和本地消息表的区别
* MQ 事务消息：需要提供事务反查，侵入性更大。
* 本地消息表：存在重复消费的问题，存储成本更高。

## 最大努力通知型
适用于外部系统的最终一致性保障，也分为 MQ 事务消息和本地消息表两种方案。
* 发送事务消息（允许消息丢失）。
* 发送方可以设置时间阶梯来重发消息，如果 N 次仍然失败，需要报警 + 日志 + 人工干预。
* 被动方需要提供幂等的接口，防止消息重复消费。
* 发送方提供查询接口供接收方查询消息状态，用于恢复丢失的业务消息。

## 补偿型
适用于需要回滚的场景，如订单支付。
### TCC
TCC 将分布式事务按业务来拆解，每个业务都需要支持三个操作（Try、Confirm、Cancel）。
* Try：预留资源，检查业务是否可以执行。
* Confirm：确认执行业务。
* Cancel：取消执行业务。
* Cancel 和 Confirm 一定要保证幂等性，因为它们执行失败需要重试。

#### TCC 和 XA 的区别
* TCC：最终一致性，不需要全程加锁，需要业务方实现 Try、Confirm、Cancel，侵入性强。
* XA：强一致性，资源管理器实现 XA 接口，全程加锁，高并发场景下性能较差。

### Saga
将一个分布式事务拆解为多个本地事务，每个本地事务都有一个补偿操作：
* LLT（Long Lived Transaction）：本地事务构成的事务链。
* 本地事务
* 补偿操作
#### 恢复策略
* 向后恢复：从失败的事务开始，执行补偿操作。
* 向前恢复：失败的事务不断重试。
#### ACID 特性
* Saga 不保证原子性和隔离性。
* Saga 通过 log 保证一致性和持久性。

### Saga 和 TCC 的区别
* Saga：适用于长事务，不需要全局锁，需要业务方实现补偿操作，无法保证隔离性。
* TCC：适用于短事务，需要全局锁，侵入性强。

<img src="/knowledge/assets/seata/cmp.png" width="750">

## Seata
Seata 是一款开源的分布式事务解决方案，支持 AT、TCC、Saga 三种模式。
### Seata AT 模式
AT（Automatic Transaction）：自动事务模式，是基于 2PC 的增强，通过代理 SQL 实现分布式事务。
* 注册全局事务，生成事务 ID。
* 执行本地事务，注册分支事务。
* 汇报分支事务执行状态。
* 收集分支事务执行状态，决定全局事务提交或回滚。
* 提交则删除 undo log。
* 回滚则看 undo log 中能否直接回滚，**不能回滚怎么办？**

<img src="/knowledge/assets/seata/seata-at.png" width="900">

#### 写隔离
* 本地事务提交前需要先获取全局事务锁。
* 如果尝试多次获取全局事务锁失败，则会回滚本地事务，释放本地锁。
* 在数据库本地隔离级别在读提交及以上的基础上，Seata AT 默认为读未提交。
#### AT 与 XA 的区别
* AT：第一阶段就提交了事务，释放锁很快。
* XA：第一阶段只是询问，第二阶段才提交，释放锁慢。

## 如何解决分布式事务的问题？
### 强一致性场景
Seata AT 模式适用于订单支付、库存扣减等强一致性场景。
* 订单库：增加订单
* 商品库：减少库存
* 优惠劵库：减少优惠劵

### 弱一致性场景
Seata TCC 模式适用于修改订单状态、支付状态等弱一致性场景。

### 最终一致性
MQ 事务消息可以保证最终一致性，适用于积分发放、优惠劵发放等最终一致性场景。