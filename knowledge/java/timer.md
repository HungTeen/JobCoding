# 定时任务
## 优先队列
### Timer
Java 提供的 Timer 基于优先队列实现，存在如下缺点：
* 插入和删除任务的时间复杂度为 O(log n)，频繁插入和删除任务会导致性能下降。
* 基于单线程，Timer 适用于定时任务较少的场景，如果定时任务较多，Timer 会出现任务堆积，导致任务执行时间不准确。

### ScheduledThreadPoolExecutor
Java 1.5 引入了 `ScheduledThreadPoolExecutor` 接口，相比 Timer 可以多线程执行任务。

### DelayQueue
`DelayQueue` 也是基于优先队列实现的，但是它的元素是带有延迟时间的元素，只有延迟时间到了才能被取出。

## 时间轮
时间轮算法被广泛应用于定时任务调度，比如 Netty 的 `HashedWheelTimer`，Dubbo 的 `HashedWheelTimer`，Spring 的 `TaskScheduler`， Caffeine 的 `TimerWheel`，还有 XXL-JOB、Kafka 等等的实现。

### 数据结构
* 时间轮一般有多个层级，可以类比时钟的时针、分针、秒针。
* 每一层是一个环形数组，数组的每一个槽位代表一个时间刻度。
* 数组的每一项是一个环形链表，链表中每个元素对应一个定时任务。
* 使用 `DelayQueue` 来存储任务，空间换时间，防止指针空推进耗费性能。

#### 为什么时间轮要多个层级，直接开一个大的数组不是一样的吗？
* 时间轮的空间复杂度更小，也更灵活。
  - 比如时间轮有 3 层，每层 10 个槽位，那么时间轮需要 3 个大小为 10 的数组即可表示 1000 的范围，而数组的话需要大小为 1000 的数组。
* 不同层级精度不同，可以减少空推进，并且时间轮可以降级，高层次的任务到一定时间会被降级到低层级。

## 参考链接
* [时间轮算法](https://juejin.cn/post/7083795682313633822)