# 乐观锁&悲观锁
## 悲观锁
悲观锁认为数据会被其他线程修改，因此在对数据进行操作时，会先加锁，确保数据不会被其他线程修改。悲观锁的实现一般是通过数据库的锁机制来实现的，比如行锁、表锁等，还有Java中的synchronized关键字、ReentrantLock等。

## 乐观锁
乐观锁认为数据不会被其他线程修改，因此在对数据进行操作时，不会加锁，而是在更新数据时判断数据是否被其他线程修改过。

乐观锁的实现一般是通过版本号或CAS算法来实现的，比如Java中的AtomicInteger、AtomicLong等。

### CAS算法
CAS（Compare And Swap）算法是一种乐观锁的实现方式，它通过比较内存中的值和期望值是否相等，如果相等则更新内存中的值，否则不更新。

CAS 是一个原子操作，底层依赖于一条CPU指令，不会被打断，因此可以保证线程安全。

Java 的 CAS 是通过 Unsafe 类的 native 方法实现的，依赖于底层 C++ 内联汇编和 JNI 调用。

### CAS的缺点
#### ABA问题
本人一直感觉 ABA 问题不是问题，直到看到如下例子：

ABA问题带来的危害：
小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50
* 线程1（提款机）：获取当前值100，期望更新为50。
* 线程2（提款机）：获取当前值100，期望更新为50。
* 线程1成功执行，线程2某种原因阻塞了，这时，某人给小明汇款50。
* 线程3（默认）：获取当前值50，期望更新为100，
* 这时候线程3成功执行，余额变为100，
* 线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！

此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的问题。

通过版本号或者时间戳可以解决 ABA 问题。

#### 循环时间长开销大
CAS 是一个自旋操作，如果一直比较不成功，会一直自旋，占用 CPU 资源，降低性能。

#### 只能保证一个共享变量的原子操作
JDK 1.5 之后提供了 AtomicReference 类，可以保证引用对象的原子操作。