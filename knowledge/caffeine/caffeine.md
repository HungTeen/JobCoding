## 读缓冲 & 写缓冲
### 读缓冲
* Caffeine 在读取缓存时会直接返回结果，但是读取导致的状态信息变动会被放入读缓冲区。
* 后台线程会定期将读缓冲区来维护缓存状态，每个线程根据 hash 映射到不同的读缓冲区（减少锁竞争）。
* 读缓冲区是一个环形缓冲区，当缓冲区满了时，会将最旧的状态信息丢弃（对于读取来说可以接受）。
### 写缓冲
* 写数据采用阻塞队列来处理。

## 缓存驱逐策略
### 基于容量的过期策略
* 基于缓存占用内存之和。
* 基于缓存权重之和。
### 基于时间的过期策略
* 基于访问时间。
* 基于写入时间。
* 基于自定义时间。
### 基于引用的过期策略
* 让 GC 来处理缓存的回收。

## 监控 & 监听
* 记录缓存是否命中、是否加载成功、是否淘汰等信息，可用于评估缓存命中率。
* 当缓存淘汰时会触发监听器，会记录淘汰原因。

## 参考链接
* [Caffeine 特性](https://juejin.cn/post/6844903670014803981)
* [Caffeine 驱逐策略](https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN)